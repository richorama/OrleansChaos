using Orleans;
using Orleans.CodeGeneration;
using Orleans.Providers;
using Orleans.Runtime;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace Chaos
{
    public class MessageTerminatorProvider : IBootstrapProvider
    {
        public string Name { get; private set; }

        public Logger Logger { get; private set; }

        InvokeInterceptor innerInterceptor = null;

        Random rand = new Random();

        double dropOutRate = 0;


        public Task Close()
        {
            return TaskDone.Done;
        }

        public Task Init(string name, IProviderRuntime providerRuntime, IProviderConfiguration config)
        {
            this.Logger = providerRuntime.GetLogger(nameof(MessageTerminatorProvider));
            this.Logger.Warn(666, $"You have enabled the {nameof(MessageTerminatorProvider)}. This should NOT be used in a production environment. Expect an increased error rate!");
            this.Name = name;

            this.dropOutRate = double.Parse(config.GetProperty("DropOutPercentage", "0.0")) / 100;

            this.Logger.Warn(666, $"Drop out rate set to {dropOutRate * 100}%");

            this.innerInterceptor = providerRuntime.GetInvokeInterceptor();
            providerRuntime.SetInvokeInterceptor(this.InvokeGrain);

            return TaskDone.Done;
        }

        bool ShouldThrow()
        {
            return rand.NextDouble() <= dropOutRate / 2;
        }

        void ThrowRandomly(string identity)
        {
            if (this.ShouldThrow())
            {
                this.Logger.Info($"{nameof(MessageTerminatorProvider)} about to throw an exception to simulate a failure calling {identity}");
                throw new TimeoutException($"This exception was generated by {nameof(MessageTerminatorProvider)} to simulate a failure calling {identity}");
            }
        }

        async Task<object> InvokeGrain(MethodInfo targetMethod, InvokeMethodRequest request, IGrain target, IGrainMethodInvoker invoker)
        {
            var identity = $"{target.GetType()}.{targetMethod?.Name ?? "?"}";

            this.ThrowRandomly(identity);

            object result = null;
            if (this.innerInterceptor != null)
            {
                result = await this.innerInterceptor(targetMethod, request, target, invoker);
            }
            else
            {
                result = await invoker.Invoke(target, request);
            }

            this.ThrowRandomly(identity);

            return result;
        }

     
    }
}
